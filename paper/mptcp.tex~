\section{Multipath TCP}
\label{sec:mptcp}

For the past several years, there has been an ongoing effort to create a multipath transport protocol that can achieve resource pooling in the Transport Layer. The result of this effort is Multipath TCP (MPTCP). Extensive research has gone into designing a congestion control algorithm for MPTCP that balances congestion and improves throughput while still being fair to legacy TCP connections\cite{raiciu2011coupled}\cite{raiciu2009practical}\cite{wischik2009control}\cite{wischik2011design}. Furthermore, MPTCP has been shown to work in practice: there is an open source implementation of MPTCP in the Linux Kernel\cite{raiciu2012hard}, and MPTCP is undergoing standardization by an IETF working group\cite{mptcpcharter}.

MPTCP is designed with the primary goal of backwards compatibility with a network designed around single path connections\cite{mptcpcharter}. This goal dictates many of the design choices around MPTCP. For example, MPTCP uses a layered approach to sequence numbers, where every packet is assigned a flow-level sequence number and a connection-level sequence number. Flow sequence numbers are put in the TCP header, while a mapping from the per-flow sequence number space to the connection-level sequence number space is established using TCP options\cite{raiciu2012hard}. This makes it so that a single flow of an MPTCP connection appears to be a legacy TCP connection from the perspective of the network, ensuring compatibility with middleboxes. However, this comes at the cost of additional per-flow state, increased complexity of the protocol, and reduced flexibility.

These and other such tradeoffs are fact a result of the ``Worse is Better'' design of the Internet. Because the network chooses simplicity over providing desired functionality, users (individuals, corporations, and designers) take it upon themselves to create this functionality in a variety of ways, often violating the end-to-end argument and the layering abstraction. This is the basic reason for the proliferation of middleboxes, and for the hoops that MPTCP has to jump through in order to create a protocol deployable on today's Internet.

There is undeniable value in creating a multipath transport protocol that works in the hostile environment of today's Internet. However, there is also merit in asking what a multipath TCP look like if it were not subject to the constraints imposed by backwards compatibility. What gains could be made if a transport protocol could be designed on top of a more flexible network abstraction? In this project I have set out to answer just this question, building on top of the Serval network architecture in the hopes of creating a simpler, more efficient, and more flexible multipath transport protocol.